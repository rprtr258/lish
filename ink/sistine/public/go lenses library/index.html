<!doctype html>

<head>
    <title>Sistine</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="/css/main.css">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&family=Newsreader:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <!-- Facebook Open Graph tags -->
    <meta property="og:url" content="https://sistine.vercel.app" />
    <meta property="og:title" content="Sistine, the static site engine" />
    <meta property="og:description" content="A simple, flexible, productive static site engine written in Ink" />
    <meta property="og:image" content="https://sistine.vercel.app/img/sistine-screenshot.png" />

    <!-- Twitter Card (large image card) tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@thesephist">
    <meta name="twitter:title" content="Sistine, the static site engine">
    <meta name="twitter:description" content="A simple, flexible, productive static site engine written in Ink" />
    <meta name="twitter:image" content="https://sistine.vercel.app/img/sistine-screenshot.png" />
</head>


<body>
<main>
    <header>
    <nav class="left-nav">
        <a href="/"><strong>Sistine</strong></a>
        <a href="/docs/">Docs</a>
        <a href="/start/">Get started</a>
    </nav>
    <nav class="right-nav">
        <a href="https://github.com/thesephist/sistine">GitHub</a>
    </nav>
</header>


    <article>
        

        
        <p>#someday_maybe #project</p><p>code generation is more viable than reflection poop</p><p><code>lens.go</code></p><pre><code data-lang="go">package lens

import (
	"reflect"
)

type Lens[S, R any] struct {
	Get func(S) R
	Set func(S, R) S
}

func New[S, R any](get func(S) R, set func(S, R) S) Lens[S, R] {
	return Lens[S, R]{
		Get: get,
		Set: set,
	}
}

func Key[K comparable, R any](key K) Lens[map[K]R, R] {
	return New(
		func(s map[K]R) R {
			return s[key]
		},
		func(s map[K]R, r R) map[K]R {
			res := map[K]R{}
			for k, v := range s {
				res[k] = v
			}
			res[key] = r
			return res
		},
	)
}

func Index[R any](idx int) Lens[[]R, R] {
	return New(
		func(s []R) R {
			return s[idx%len(s)]
		},
		func(s []R, r R) []R {
			idx := idx % len(s)
			res := make([]R, len(s))
			copy(res, s)
			res[idx] = r
			return res
		},
	)
}

// func Copy[S any](s S) S {
// 	bytes, _ := json.Marshal(s)
// 	var res S
// 	_ = json.Unmarshal(bytes, &amp;res)
// 	return res
// }

func StructField[S, R any](field string) Lens[S, R] {
	return New(
		func(s S) R {
			return reflect.ValueOf(s).FieldByName(field).Interface().(R)
		},
		func(s S, r R) S {
			source := reflect.ValueOf(s)
			res := reflect.New(reflect.TypeOf(s)).Elem()
			fields := res.NumField()
			for i := 0; i &lt; fields; i++ {
				res.Field(i).Set(source.Field(i))
			}
			res.FieldByName(field).Set(reflect.ValueOf(r))
			return res.Interface().(S)
		},
	)
}

func Compose[S, T, R any](l1 Lens[S, T], l2 Lens[T, R]) Lens[S, R] {
	return New(
		func(s S) R {
			return l2.Get(l1.Get(s))
		},
		func(s S, r R) S {
			return l1.Set(s, l2.Set(l1.Get(s), r))
		},
	)
}

func Over[S, R any](l Lens[S, R], f func(R) R, s S) S {
	return l.Set(s, f(l.Get(s)))
}</code></pre><p><code>lens_test.go</code></p><pre><code data-lang="go">package lens_test

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"lens"
)

type User struct {
	ID      uint64
	Name    string
	Friends []string
}

var (
	_userIDLens      = lens.StructField[User, uint64]("ID")
	_userNameLens    = lens.StructField[User, string]("Name")
	_userFriendsLens = lens.StructField[User, []string]("Friends")
)

func TestGetID(t *testing.T) {
	u := User{
		ID:   1,
		Name: "a",
	}
	assert.Equal(t, uint64(1), _userIDLens.Get(u))
}

func TestSetID(t *testing.T) {
	u := User{
		ID:   1,
		Name: "a",
	}
	got := _userNameLens.Set(u, "b")

	assert.Equal(t, User{
		ID:   1,
		Name: "a",
	}, u)
	assert.Equal(t, User{
		ID:   1,
		Name: "b",
	}, got)
}

func TestSetFriend(t *testing.T) {
	u := User{
		ID:      1,
		Name:    "a",
		Friends: []string{"x", "d", "d"},
	}
	l := lens.Compose(_userFriendsLens, lens.Index[string](2))
	got := l.Set(u, "y")

	assert.Equal(t, User{
		ID:      1,
		Name:    "a",
		Friends: []string{"x", "d", "d"},
	}, u)

	assert.Equal(t, User{
		ID:      1,
		Name:    "a",
		Friends: []string{"x", "d", "y"},
	}, got)
}</code></pre>
    </article>

    <footer>
    <p>
        Sistine is a project by
        <a href="https://thesephist.com/" target="_blank">Linus</a>
        built with
        <a href="https://dotink.co/" target="_blank">Ink</a>.
    </p>
</footer>

</main>

<script src="/js/main.js"></script>

</body>
