std = load(__Ink_String(`../vendor/std`));
str = load(__Ink_String(`../vendor/str`));
f = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[format] || null : (__ink_acc_trgt.format !== undefined ? __ink_acc_trgt.format : null)})();
each = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[each] || null : (__ink_acc_trgt.each !== undefined ? __ink_acc_trgt.each : null)})();
reduce = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[reduce] || null : (__ink_acc_trgt.reduce !== undefined ? __ink_acc_trgt.reduce : null)})();
filter = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[filter] || null : (__ink_acc_trgt.filter !== undefined ? __ink_acc_trgt.filter : null)})();
lower = (() => {let __ink_acc_trgt = __as_ink_string(str); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[lower] || null : (__ink_acc_trgt.lower !== undefined ? __ink_acc_trgt.lower : null)})();
split = (() => {let __ink_acc_trgt = __as_ink_string(str); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[split] || null : (__ink_acc_trgt.split !== undefined ? __ink_acc_trgt.split : null)})();
lower = (() => {let __ink_acc_trgt = __as_ink_string(str); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[lower] || null : (__ink_acc_trgt.lower !== undefined ? __ink_acc_trgt.lower : null)})();
Stopwords = [__Ink_String(`a`), __Ink_String(`about`), __Ink_String(`an`), __Ink_String(`are`), __Ink_String(`and`), __Ink_String(`as`), __Ink_String(`at`), __Ink_String(`be`), __Ink_String(`but`), __Ink_String(`by`), __Ink_String(`co`), __Ink_String(`com`), __Ink_String(`do`), __Ink_String(`don't`), __Ink_String(`for`), __Ink_String(`from`), __Ink_String(`has`), __Ink_String(`have`), __Ink_String(`he`), __Ink_String(`his`), __Ink_String(`http`), __Ink_String(`https`), __Ink_String(`i`), __Ink_String(`i'm`), __Ink_String(`in`), __Ink_String(`is`), __Ink_String(`it`), __Ink_String(`it's`), __Ink_String(`just`), __Ink_String(`like`), __Ink_String(`me`), __Ink_String(`my`), __Ink_String(`not`), __Ink_String(`of`), __Ink_String(`on`), __Ink_String(`or`), __Ink_String(`rt`), __Ink_String(`so`), __Ink_String(`t`), __Ink_String(`that`), __Ink_String(`the`), __Ink_String(`they`), __Ink_String(`this`), __Ink_String(`to`), __Ink_String(`twitter`), __Ink_String(`was`), __Ink_String(`we`), __Ink_String(`were`), __Ink_String(`with`), __Ink_String(`you`), __Ink_String(`your`)];
StopwordMap = {};
each(Stopwords, word => (() => {let __ink_assgn_trgt = __as_ink_string(StopwordMap); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return word })(), true) : (__ink_assgn_trgt[(() => { return word })()]) = true; return __ink_assgn_trgt})());
notStopword__ink_qm__ = w => __ink_eq((() => {let __ink_acc_trgt = __as_ink_string(StopwordMap); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return w })()] || null : (__ink_acc_trgt[(() => { return w })()] !== undefined ? __ink_acc_trgt[(() => { return w })()] : null)})(), null);
Puncts = __Ink_String(`.,:;?!#%*()[]{}\\|/<>~"-_`);
punct__ink_qm__ = c => (() => { let __ink_trampolined_sub; let sub; return sub = i => (() => { __ink_trampolined_sub = i => __ink_match((() => {let __ink_acc_trgt = __as_ink_string(Puncts); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return i })()] || null : (__ink_acc_trgt[(() => { return i })()] !== undefined ? __ink_acc_trgt[(() => { return i })()] : null)})(), [[() => (null), () => (false)], [() => (c), () => (true)], [() => (__Ink_Empty), () => (__ink_trampoline(__ink_trampolined_sub, __as_ink_string(i + 1)))]]); return __ink_resolve_trampoline(__ink_trampolined_sub, i) })() })()(0);
control__ink_qm__ = c => (point(c) < 32);
removePunct = s => (() => { let __ink_trampolined_sub; let sub; return sub = i => (() => { __ink_trampolined_sub = i => (() => { let c; return __ink_match(c = (() => {let __ink_acc_trgt = __as_ink_string(s); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return i })()] || null : (__ink_acc_trgt[(() => { return i })()] !== undefined ? __ink_acc_trgt[(() => { return i })()] : null)})(), [[() => (null), () => (s)], [() => (__Ink_Empty), () => ((() => { __ink_match(punct__ink_qm__(c), [[() => (true), () => ((() => {let __ink_assgn_trgt = __as_ink_string(s); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return i })(), __Ink_String(` `)) : (__ink_assgn_trgt[(() => { return i })()]) = __Ink_String(` `); return __ink_assgn_trgt})())], [() => (__Ink_Empty), () => (__ink_match(control__ink_qm__(c), [[() => (true), () => ((() => {let __ink_assgn_trgt = __as_ink_string(s); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return i })(), __Ink_String(` `)) : (__ink_assgn_trgt[(() => { return i })()]) = __Ink_String(` `); return __ink_assgn_trgt})())]]))]]); return __ink_trampoline(__ink_trampolined_sub, __as_ink_string(i + 1)) })())]]) })(); return __ink_resolve_trampoline(__ink_trampolined_sub, i) })() })()(0);
whitespace__ink_qm__ = c => __ink_match(point(c), [[() => (9), () => (true)], [() => (10), () => (true)], [() => (13), () => (true)], [() => (32), () => (true)], [() => (__Ink_Empty), () => (false)]]);
splitByWhitespace = s => (() => { let __ink_trampolined_sub; let sub; return sub = (acc, i, sofar) => (() => { __ink_trampolined_sub = (acc, i, sofar) => (() => { let c; return __ink_match(c = (() => {let __ink_acc_trgt = __as_ink_string(s); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return i })()] || null : (__ink_acc_trgt[(() => { return i })()] !== undefined ? __ink_acc_trgt[(() => { return i })()] : null)})(), [[() => (null), () => (__ink_match(sofar, [[() => (__Ink_String(``)), () => (acc)], [() => (__Ink_Empty), () => ((() => {let __ink_assgn_trgt = __as_ink_string(acc); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(len(acc), sofar) : (__ink_assgn_trgt[len(acc)]) = sofar; return __ink_assgn_trgt})())]]))], [() => (__Ink_Empty), () => (__ink_match(whitespace__ink_qm__(c), [[() => (true), () => (__ink_match(sofar, [[() => (__Ink_String(``)), () => (__ink_trampoline(__ink_trampolined_sub, acc, __as_ink_string(i + 1), __Ink_String(``)))], [() => (__Ink_Empty), () => (__ink_trampoline(__ink_trampolined_sub, (() => {let __ink_assgn_trgt = __as_ink_string(acc); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(len(acc), sofar) : (__ink_assgn_trgt[len(acc)]) = sofar; return __ink_assgn_trgt})(), __as_ink_string(i + 1), __Ink_String(``)))]]))], [() => (__Ink_Empty), () => (__ink_match(c, [[() => (null), () => (acc)], [() => (__Ink_Empty), () => (__ink_trampoline(__ink_trampolined_sub, acc, __as_ink_string(i + 1), __as_ink_string(sofar + c)))]]))]]))]]) })(); return __ink_resolve_trampoline(__ink_trampolined_sub, acc, i, sofar) })() })()([], 0, __Ink_String(``));
tokenize = s => (() => { let tokens; s = __as_ink_string(__Ink_String(``) + s); removePunct(s); tokens = filter(splitByWhitespace(lower(s)), notStopword__ink_qm__); return reduce(tokens, (freqs, tok) => (() => { let freq; return __ink_match(freq = (() => {let __ink_acc_trgt = __as_ink_string(freqs); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return tok })()] || null : (__ink_acc_trgt[(() => { return tok })()] !== undefined ? __ink_acc_trgt[(() => { return tok })()] : null)})(), [[() => (null), () => ((() => {let __ink_assgn_trgt = __as_ink_string(freqs); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return tok })(), 1) : (__ink_assgn_trgt[(() => { return tok })()]) = 1; return __ink_assgn_trgt})())], [() => (__Ink_Empty), () => ((() => {let __ink_assgn_trgt = __as_ink_string(freqs); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return tok })(), __as_ink_string(freq + 1)) : (__ink_assgn_trgt[(() => { return tok })()]) = __as_ink_string(freq + 1); return __ink_assgn_trgt})())]]) })(), {}) })()

std = load(__Ink_String(`../vendor/std`));
each = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[each] || null : (__ink_acc_trgt.each !== undefined ? __ink_acc_trgt.each : null)})();
indexDoc = (index, doc) => each(keys((() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[tokens] || null : (__ink_acc_trgt.tokens !== undefined ? __ink_acc_trgt.tokens : null)})()), token => (() => { let docIDs; return __ink_match(docIDs = (() => {let __ink_acc_trgt = __as_ink_string(index); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return token })()] || null : (__ink_acc_trgt[(() => { return token })()] !== undefined ? __ink_acc_trgt[(() => { return token })()] : null)})(), [[() => (null), () => ((() => {let __ink_assgn_trgt = __as_ink_string(index); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return token })(), [(() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[id] || null : (__ink_acc_trgt.id !== undefined ? __ink_acc_trgt.id : null)})()]) : (__ink_assgn_trgt[(() => { return token })()]) = [(() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[id] || null : (__ink_acc_trgt.id !== undefined ? __ink_acc_trgt.id : null)})()]; return __ink_assgn_trgt})())], [() => (__Ink_Empty), () => ((() => {let __ink_assgn_trgt = __as_ink_string(docIDs); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(len(docIDs), (() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[id] || null : (__ink_acc_trgt.id !== undefined ? __ink_acc_trgt.id : null)})()) : (__ink_assgn_trgt[len(docIDs)]) = (() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[id] || null : (__ink_acc_trgt.id !== undefined ? __ink_acc_trgt.id : null)})(); return __ink_assgn_trgt})())]]) })());
indexDocs = docs => (() => { let index; index = {}; each(keys(docs), docID => indexDoc(index, (() => {let __ink_acc_trgt = __as_ink_string(docs); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return docID })()] || null : (__ink_acc_trgt[(() => { return docID })()] !== undefined ? __ink_acc_trgt[(() => { return docID })()] : null)})())); return index })()

std = load(__Ink_String(`../vendor/std`));
quicksort = load(__Ink_String(`../vendor/quicksort`));
fastsort = load(__Ink_String(`fastsort.js`));
map = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[map] || null : (__ink_acc_trgt.map !== undefined ? __ink_acc_trgt.map : null)})();
reduce = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[reduce] || null : (__ink_acc_trgt.reduce !== undefined ? __ink_acc_trgt.reduce : null)})();
envSortBy = (() => { return __ink_match((() => {let __ink_acc_trgt = __as_ink_string(fastsort); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[available__ink_qm__] || null : (__ink_acc_trgt.available__ink_qm__ !== undefined ? __ink_acc_trgt.available__ink_qm__ : null)})(), [[() => (true), () => ((() => {let __ink_acc_trgt = __as_ink_string(fastsort); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[fastSortBy] || null : (__ink_acc_trgt.fastSortBy !== undefined ? __ink_acc_trgt.fastSortBy : null)})())], [() => (__Ink_Empty), () => ((() => {let __ink_acc_trgt = __as_ink_string(quicksort); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[sortBy] || null : (__ink_acc_trgt.sortBy !== undefined ? __ink_acc_trgt.sortBy : null)})())]]) })();
rankDocs = (matchingDocs, queryTokens, lenDocs) => envSortBy(matchingDocs, doc => (reduce(queryTokens, (acc, token) => (acc - (() => {let __ink_acc_trgt = __as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[tokens] || null : (__ink_acc_trgt.tokens !== undefined ? __ink_acc_trgt.tokens : null)})()); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return token })()] || null : (__ink_acc_trgt[(() => { return token })()] !== undefined ? __ink_acc_trgt[(() => { return token })()] : null)})()), 0) * ln((lenDocs / len((() => {let __ink_acc_trgt = __as_ink_string(doc); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[tokens] || null : (__ink_acc_trgt.tokens !== undefined ? __ink_acc_trgt.tokens : null)})())))))

std = load(__Ink_String(`../vendor/std`));
str = load(__Ink_String(`../vendor/str`));
filter = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[filter] || null : (__ink_acc_trgt.filter !== undefined ? __ink_acc_trgt.filter : null)})();
hasSuffix__ink_qm__ = (() => {let __ink_acc_trgt = __as_ink_string(str); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[hasSuffix__ink_qm__] || null : (__ink_acc_trgt.hasSuffix__ink_qm__ !== undefined ? __ink_acc_trgt.hasSuffix__ink_qm__ : null)})();
trimSuffix = (() => {let __ink_acc_trgt = __as_ink_string(str); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[trimSuffix] || null : (__ink_acc_trgt.trimSuffix !== undefined ? __ink_acc_trgt.trimSuffix : null)})();
tokenizer = load(__Ink_String(`tokenizer`));
tokenize = (() => {let __ink_acc_trgt = __as_ink_string(tokenizer); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[tokenize] || null : (__ink_acc_trgt.tokenize !== undefined ? __ink_acc_trgt.tokenize : null)})();
uniq = list => keys(reduce(list, (set, it) => (() => {let __ink_assgn_trgt = __as_ink_string(set); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return it })(), true) : (__ink_assgn_trgt[(() => { return it })()]) = true; return __ink_assgn_trgt})(), {}));
removeRepeatedLastLetter = word => __ink_match((len(word) < 3), [[() => (true), () => (word)], [() => (__Ink_Empty), () => (__ink_match((() => {let __ink_acc_trgt = __as_ink_string(word); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return (len(word) - 1) })()] || null : (__ink_acc_trgt[(() => { return (len(word) - 1) })()] !== undefined ? __ink_acc_trgt[(() => { return (len(word) - 1) })()] : null)})(), [[() => ((() => {let __ink_acc_trgt = __as_ink_string(word); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return (len(word) - 2) })()] || null : (__ink_acc_trgt[(() => { return (len(word) - 2) })()] !== undefined ? __ink_acc_trgt[(() => { return (len(word) - 2) })()] : null)})()), () => (slice(word, 0, (len(word) - 1)))], [() => (__Ink_Empty), () => (word)]]))]]);
repeatLastLetter = word => __as_ink_string(word + (() => {let __ink_acc_trgt = __as_ink_string(word); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return (len(word) - 1) })()] || null : (__ink_acc_trgt[(() => { return (len(word) - 1) })()] !== undefined ? __ink_acc_trgt[(() => { return (len(word) - 1) })()] : null)})());
getStem = word => (() => { let stem; stem = (() => { return __ink_match(true, [[() => (hasSuffix__ink_qm__(word, __Ink_String(`ation`))), () => (__as_ink_string(trimSuffix(word, __Ink_String(`ation`)) + __Ink_String(`e`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`tion`))), () => (__as_ink_string(trimSuffix(word, __Ink_String(`tion`)) + __Ink_String(`te`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`ies`))), () => (__as_ink_string(trimSuffix(word, __Ink_String(`ies`)) + __Ink_String(`y`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`ing`))), () => (removeRepeatedLastLetter(trimSuffix(word, __Ink_String(`ing`))))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`or`))), () => (__as_ink_string(removeRepeatedLastLetter(trimSuffix(word, __Ink_String(`or`))) + __Ink_String(`e`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`er`))), () => (__as_ink_string(removeRepeatedLastLetter(trimSuffix(word, __Ink_String(`er`))) + __Ink_String(`e`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`ed`))), () => (removeRepeatedLastLetter(trimSuffix(word, __Ink_String(`ed`))))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`ment`))), () => (trimSuffix(word, __Ink_String(`ment`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`ly`))), () => (trimSuffix(word, __Ink_String(`ly`)))], [() => (hasSuffix__ink_qm__(word, __Ink_String(`s`))), () => (trimSuffix(word, __Ink_String(`s`)))], [() => (__Ink_Empty), () => (word)]]) })(); return __ink_match(stem, [[() => (__Ink_String(``)), () => (word)], [() => (__Ink_Empty), () => (stem)]]) })();
generateVariations = (word, stem) => uniq(filter([word, stem, __as_ink_string(stem + __Ink_String(`e`)), __as_ink_string(stem + __Ink_String(`s`)), __as_ink_string(stem + __Ink_String(`ly`)), __as_ink_string(stem + __Ink_String(`ment`)), __as_ink_string(stem + __Ink_String(`'s`)), __as_ink_string(stem + __Ink_String(`ed`)), __as_ink_string(repeatLastLetter(stem) + __Ink_String(`ed`)), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`e`)), [[() => (true), () => (__as_ink_string(stem + __Ink_String(`d`)))], [() => (__Ink_Empty), () => (__as_ink_string(stem + __Ink_String(`ed`)))]]), __as_ink_string(stem + __Ink_String(`er`)), __as_ink_string(repeatLastLetter(stem) + __Ink_String(`er`)), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`e`)), [[() => (true), () => (__as_ink_string(stem + __Ink_String(`r`)))], [() => (__Ink_Empty), () => (__as_ink_string(stem + __Ink_String(`er`)))]]), __as_ink_string(stem + __Ink_String(`or`)), __as_ink_string(repeatLastLetter(stem) + __Ink_String(`or`)), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`e`)), [[() => (true), () => (__as_ink_string(stem + __Ink_String(`r`)))], [() => (__Ink_Empty), () => (__as_ink_string(stem + __Ink_String(`or`)))]]), __as_ink_string(stem + __Ink_String(`ing`)), __as_ink_string(repeatLastLetter(stem) + __Ink_String(`ing`)), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`e`)), [[() => (true), () => (__as_ink_string(trimSuffix(stem, __Ink_String(`e`)) + __Ink_String(`ing`)))], [() => (__Ink_Empty), () => (__as_ink_string(stem + __Ink_String(`ing`)))]]), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`y`)), [[() => (true), () => (__as_ink_string(trimSuffix(stem, __Ink_String(`y`)) + __Ink_String(`ies`)))]]), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`te`)), [[() => (true), () => (__as_ink_string(trimSuffix(stem, __Ink_String(`te`)) + __Ink_String(`tion`)))]]), __ink_match(hasSuffix__ink_qm__(stem, __Ink_String(`e`)), [[() => (true), () => (__as_ink_string(trimSuffix(stem, __Ink_String(`e`)) + __Ink_String(`ation`)))]])], w => __ink_negate((() => { return __ink_eq(w, null) })())));
variationsOfWord = word => generateVariations(word, getStem(word));
tokenizeAndVary = s => (() => { let tokens; tokens = keys(tokenize(s)); return sortBy(flatten(map(tokens, variationsOfWord)), w => __ink_negate(len(w))) })()

std = load(__Ink_String(`../vendor/std`));
map = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[map] || null : (__ink_acc_trgt.map !== undefined ? __ink_acc_trgt.map : null)})();
slice = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[slice] || null : (__ink_acc_trgt.slice !== undefined ? __ink_acc_trgt.slice : null)})();
filter = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[filter] || null : (__ink_acc_trgt.filter !== undefined ? __ink_acc_trgt.filter : null)})();
reduce = (() => {let __ink_acc_trgt = __as_ink_string(std); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[reduce] || null : (__ink_acc_trgt.reduce !== undefined ? __ink_acc_trgt.reduce : null)})();
tokenizer = load(__Ink_String(`tokenizer`));
ranker = load(__Ink_String(`ranker`));
tokenize = (() => {let __ink_acc_trgt = __as_ink_string(tokenizer); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[tokenize] || null : (__ink_acc_trgt.tokenize !== undefined ? __ink_acc_trgt.tokenize : null)})();
rankDocs = (() => {let __ink_acc_trgt = __as_ink_string(ranker); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[rankDocs] || null : (__ink_acc_trgt.rankDocs !== undefined ? __ink_acc_trgt.rankDocs : null)})();
listToSet = list => reduce(list, (acc, it) => (() => {let __ink_assgn_trgt = __as_ink_string(acc); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return it })(), true) : (__ink_assgn_trgt[(() => { return it })()]) = true; return __ink_assgn_trgt})(), {});
intersectionSet = (a, b) => reduce(keys(a), (intersection, it) => __ink_match((() => {let __ink_acc_trgt = __as_ink_string(b); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return it })()] || null : (__ink_acc_trgt[(() => { return it })()] !== undefined ? __ink_acc_trgt[(() => { return it })()] : null)})(), [[() => (true), () => ((() => {let __ink_assgn_trgt = __as_ink_string(intersection); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return it })(), true) : (__ink_assgn_trgt[(() => { return it })()]) = true; return __ink_assgn_trgt})())], [() => (__Ink_Empty), () => (intersection)]]), {});
findDocs = (index, docs, query) => (() => { let queryTokens; return __ink_match(queryTokens = keys(tokenize(query)), [[() => ([]), () => ([])], [() => (__Ink_Empty), () => ((() => { let docMatches; let docMatchesAsMaps; let matchingDocIDs; let matchingDocs; docMatches = map(queryTokens, token => (() => { let variationDocSet; let variations; variations = variationsOfWord(token); variationDocSet = {}; each(variations, __ink_ident_var => (() => { let docIDs; return __ink_match(docIDs = (() => {let __ink_acc_trgt = __as_ink_string(index); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return __ink_ident_var })()] || null : (__ink_acc_trgt[(() => { return __ink_ident_var })()] !== undefined ? __ink_acc_trgt[(() => { return __ink_ident_var })()] : null)})(), [[() => (null), () => (null)], [() => (__Ink_Empty), () => (each(docIDs, id => (() => {let __ink_assgn_trgt = __as_ink_string(variationDocSet); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign((() => { return id })(), true) : (__ink_assgn_trgt[(() => { return id })()]) = true; return __ink_assgn_trgt})()))]]) })()); return keys(variationDocSet) })()); docMatchesAsMaps = map(docMatches, listToSet); matchingDocIDs = keys(reduce(slice(docMatchesAsMaps, 1, len(docMatchesAsMaps)), intersectionSet, (() => {let __ink_acc_trgt = __as_ink_string(docMatchesAsMaps); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})())); matchingDocs = map(matchingDocIDs, id => (() => {let __ink_acc_trgt = __as_ink_string(docs); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[(() => { return id })()] || null : (__ink_acc_trgt[(() => { return id })()] !== undefined ? __ink_acc_trgt[(() => { return id })()] : null)})()); return rankDocs(matchingDocs, tokenizeAndVary(query), len(docs)) })())]]) })()

