(setmacro defun (lambda (f args body)
    `(set! ~f
        (lambda ~args ~body))))

(setmacro defmacro (lambda (m args body)
    `(setmacro ~m
        (lambda ~args ~body))))

(defmacro if (p x y)
    `(cond ~p ~x ~y))

(defmacro when (p x)
    `(cond ~p ~x ()))

(defmacro compose (& fs)
  (let*
    (compose* (lambda (fs)
      (if
        (nil? fs)
        `x
        (let*
          (cur-fun (car fs)
          rest-funs (cdr fs))
          `(~cur-fun ~(compose* rest-funs))))))
    `(lambda (x) ~(compose* fs))))

(defmacro swap! (x f) `(set! ~x (~f ~x)))

(set! cadr (compose car cdr))
(set! cddr (compose cdr cdr))
(set! caddr (compose car cddr))
(set! cdddr (compose cdr cddr))
(defmacro letfun (exps body)
  (let* (bindings ((defun f (expss)
      (if
        (nil? expss)
        ()
        (let*
          (fun-name (car expss)
          fun-args (cadr expss)
          fun-body (caddr expss)
          rest (cdddr expss))
          `(~fun-name (defun ~fun-name ~fun-args ~fun-body) ~@(f rest)))))
      exps))
  `(let* ~bindings ~body)))

; TODO: rewrite with meta and set!
(defmacro defun-trace (f args body)
  `(defun ~f ~args
    (let*
      (res ~body)
      (progn
        (echo "(" '~f " " (str ~@args) ") = " res)
        res))))

; anaphoric lambda, argument binds to %
(defmacro # (body) `(lambda (%) ~body))

(defun map (f xs)
    (if
      (nil? xs)
      ()
      (cons (f (car xs)) (map f (cdr xs)))))

; rename to for
(defmacro doseq (seq-exprs body)
  ((defun doseq* (sxs body)
    (let*
      (var-name (car sxs)
      var-seq (cadr sxs)
      the-body (if
        (nil? (cddr sxs))
        body
        (doseq* (cddr sxs) body)))
      `(map
        (lambda (~var-name) ~the-body)
        ~var-seq)))
  seq-exprs body))

(defmacro cons-if (p x y s)
  `(cons (if ~p ~x ~y) s))

(defmacro -> (& x)
    (if
        (= (len x) 1)
        (car x)
        (let*
            (fst (car x)
            next-f (cadr x)
            rest (cddr x)
            new-val (if
              (atom? next-f)
              `(~next-f ~fst)
              `(~(car next-f) ~fst ~@(cdr next-f))))
            `(-> ~new-val ~@rest))))

(defmacro >-> (x)
    (if
        (= (len x) 1)
        (car x)
        (let*
            (fst (car x)
            next-f (cadr x)
            rest (cddr x))
            (>->
                (cons-if
                    (atom? next-f)
                    `(~next-f ~fst)
                    `((lambda (%%) ~next-f) ~fst))
                    rest))))

(defmacro juxt (& fs)
    `(lambda (x)
        (map
            (lambda (f) (f x))
            ~fs)))
