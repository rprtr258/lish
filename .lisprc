; ============ MACRO SECTION ============

; not effective due to heavy recursion
;(define map (lambda (f xs)
;    (cond
;        (nil? xs) '()
;        (cons (f (car xs)) (map f (cdr xs))))))
;(define map (lambda (f xs)
;    (loop (res '() ys xs)
;        (cond
;            (nil? ys) '()
;            (recur (cons (f (car ys)) res) (cdr ys))))))

(defmacro ` (f)
    ((define `` (lambda (f)
        (cond
            (atom? f) (list 'quote f)
            (= '~ (car f)) (car (cdr f))
            (cons
                'list
                (map `` f)))))
    f))

(defmacro defun (f args body)
    (` (define (~ f)
        (lambda (~ args) (~ body)))))
(defmacro if (p x y)
    (` (cond
        (~ p) (~ x)
        (~ y))))

(defun evens (x)
    (if
        (nil? x)
        '()
        (cons
            (car x)
            (odds (cdr x)))))
(defun odds (x)
    (if
        (nil? x)
        '()
        (evens (cdr x))))
(defmacro let (exps body)
    (cons (`
        (lambda
            (~ (evens exps))
            (~ body)))
        (odds exps)))

; TODO: change to variadic func
(defmacro compose (f g) (` (lambda (x) ((~ f) ((~ g) x)))))
(define cadr (compose car cdr))
(define cddr (compose cdr cdr))
(define caddr (compose car cddr))
(define cdddr (compose cdr cddr))
(defmacro letfun (exps body)
    (` (let
        (~ ((defun f (expss)
            (if
                (nil? expss)
                '()
                (let
                    (fun-name (car expss)
                    fun-args (cadr expss)
                    fun-body (caddr expss)
                    rest (cdddr expss))
                    (+
                        (` ((~ fun-name) (defun (~ fun-name) (~ fun-args) (~ fun-body))))
                        (f rest))))) exps))
        (~ body))))

(defmacro defun-trace (f args body)
    (` (defun (~ f) (~ args)
        (let
            (res (~ body))
            (progn
                (echo (~ (name f)) " " (~ (cons 'list args)) " " res)
                res)))))

; anaphoric lambda, argument binds to %
(defmacro # (body) (` (lambda (%) (~ body))))

(defmacro doseq (seq-exprs body)
    ((defun doseq-helper (sxs body)
        (let
            (var-name (car sxs)
            var-seq (cadr sxs)
            the-body (if
                (nil? (cddr sxs))
                body
                (doseq-helper (cddr sxs) body)))
            (` (map
                (lambda ((~ var-name)) (~ the-body))
                (~ var-seq)))))
    seq-exprs body))

(defun single? (x) (= (len x) 1))
(defmacro cons-if (p x y s) (` (cons (if (~ p) (~ x) (~ y)) (~ s))))

(defmacro -> (x) ((defun ->-helper (y)
    (if
        (single? y)
        (car y)
        (let
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (->-helper
                (cons-if
                    (atom? next-f)
                    (` ((~ next-f) (~ fst)))
                    (cons (car next-f) fst (cdr next-f))
                    rest)))))
    x))

(defmacro >-> (x) ((defun >->-helper (y)
    (if
        (single? y)
        (car y)
        (let
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (>->-helper
                (cons-if
                    (atom? next-f)
                    (` ((~ next-f) (~ fst)))
                    (` ((lambda (%%) (~ next-f)) (~ fst)))
                    rest)))))
    x))

(defmacro juxt (fs)
    (` (lambda (x)
        (map
            (# (% x))
            (~ (cons 'list fs))))))

; ============ FUNCTIONS SECTION ============

(defun dec (n) (- n 1))
(defun inc (n) (+ n 1))

(defun-trace fact-t (n)
    (if
        (= n 1) 1
        (* n (fact-t (dec n)))))

(defun-trace fib (n)
    (if
        (< n 2) n
        (+
            (fib (- n 1))
            (fib (- n 2)))))

(defun fact (n)
    (if
        (= n 1)
        1
        (*
            n
            (fact (dec n)))))


(defun range (n)
    (letfun
        (range-helper (k n)
            (if
                (= k n)
                '()
                (cons k (range-helper (inc k) n))))
        (range-helper 0 n)))


; (map* * '((1 2 3) (-1 0 1))
; (-1 0 3)
(defun map* (f xss)
    (if
        (apply or (map nil? xss)) '()
        (cons
            (apply f (map car xss))
            (map* f (map cdr xss)))))

; (*map (# (list % (inc %))) '(1 2 3))
; (1 2 2 3 3 4)
(defun *map (f xs)
    (if
        (nil? xs) '()
        (+
            (f (car xs))
            (*map f (cdr xs)))))

(defun take (n x)
    (if
        (or (nil? x) (= n 0))
        '()
        (cons (car x) (take (dec n) (cdr x)))))

(defun drop (n x)
    (if
        (or (nil? x) (= n 0))
        x
        (drop (dec n) (cdr x))))

(defun id (x) x)

; ============ PLAY ZONE ============








(echo "el0chka")
(doseq (x '(1 1 1) y '(1 3 5 7))
    (-> ("*" (* y) echo)))

(echo)
(echo "almaz")
(doseq (x '(1 3 5 7 5 3 1))
    (echo (* " " (- 7 x)) (* "*" (* x 2))))




(define prompt
  (let (cnt 0)
    (lambda () (progn
      (set! cnt (inc cnt))
      (+ "lis.py(" (str cnt) ")> ")))))



;(doseq (x '(-1 0 1)
;       y '(1 2 3))
;    (echo (* x y)))
