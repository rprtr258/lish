; not effective due to heavy recursion
;(define map (lambda (f xs)
;    (cond
;        (nil? xs) '()
;        (cons (f (car xs)) (map f (cdr xs))))))

(define `` (lambda (f)
    (cond
        (atom? f) (list 'quote f)
        (= '~ (car f)) (car (cdr f))
        (cons
            'list
            (map `` f)))))
(defmacro ` (f) (`` f))

(defmacro defun (f args body) (` (define (~ f) (lambda (~ args) (~ body)))))
(defmacro if (p x y) (` (cond (~ p) (~ x) (~ y))))

(defun evens (x)
    (cond
        (nil? x) '()
        (cons
            (car x)
            (odds (cdr x)))))
(defun odds (x)
    (cond
        (nil? x) '()
        (evens (cdr x))))
(defmacro let (exps body)
    (cons (`
        (lambda
            (~ (evens exps))
            (~ body)))
        (odds exps)))

(defun cadr (x) (car (cdr x)))
(defun cddr (x) (cdr (cdr x)))
(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defmacro letfun (exps body)
    (` (let
        (~ ((defun f (expss)
            (cond
                (nil? expss) '()
                (let
                    (fun-name (car expss)
                    fun-args (cadr expss)
                    fun-body (caddr expss)
                    rest (cdddr expss))
                    (+
                        (` ((~ fun-name) (defun (~ fun-name) (~ fun-args) (~ fun-body))))
                        (f rest))))) exps))
        (~ body))))

(defmacro defun-trace (f args body)
    (` (define
        (~ f)
        (lambda
            (~ args)
            (let
                (res (~ body))
                (progn
                    (echo '(~ f) (~ (car args)) res)
                    res))))))

(defmacro # (body) (` (lambda (%) (~ body))))

(defun doseq-helper (sxs body)
    (let
        (var-name (car sxs)
        var-seq (car (cdr sxs))
        rest (cdr (cdr sxs)))
        (cond
            (nil? rest) (` (map
                (lambda ((~ var-name)) (~ body))
                (~ var-seq)))
            (` (map
                (lambda ((~ var-name)) (~ (doseq-helper rest body)))
                (~ var-seq))))))
(defmacro doseq (seq-exprs body) (doseq-helper seq-exprs body))













(defun dec (n) (- n 1))
(defun inc (n) (+ n 1))

(defun-trace fact-t (n)
    (cond
        (= n 1) 1
        (* n (fact-t (dec n)))))
(defun-trace fib (n)
    (cond
        (< n 2) n
        (+
            (fib (- n 1))
            (fib (- n 2)))))

(defun fact (n)
    (cond
        (= n 1) 1
        (*
            n
            (fact (dec n)))))


(defun range (n)
    (letfun
        (range-helper (k n) (cond
            (= k n) '()
            (cons k (range-helper (inc k) n))))
        (range-helper 0 n)))


; (map* * '((1 2 3) (-1 0 1))
; (-1 0 3)
(defun map* (f xss)
    (cond
        (apply or (map nil? xss)) '()
        (cons
            (apply f (map car xss))
            (map* f (map cdr xss)))))

; (*map (# (list % (inc %))) '(1 2 3))
; (1 2 2 3 3 4)
(defun *map (f xs)
    (cond
        (nil? xs) '()
        (+
            (f (car xs))
            (*map f (cdr xs)))))

(defun take (n x)
    (cond
        (or (nil? x) (= n 0)) '()
        (cons (car x) (take (dec n) (cdr x)))))

(defun drop (n x)
    (cond
        (or (nil? x) (= n 0)) x
        (drop (dec n) (cdr x))))










(echo "el0chka")
(doseq (x '(1 1 1) y '(1 3 5 7))
    (echo (* "*" y)))

(echo)
(echo "almaz")
(doseq (x '(1 3 5 7 5 3 1))
    (echo (* " " (- 7 x)) (* "*" (* x 2))))





;(doseq (x '(-1 0 1)
;       y '(1 2 3))
;    (echo (* x y)))