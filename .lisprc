; ============ MACRO SECTION ============

(set! map (lambda (f xs)
    (cond
        (nil? xs) '()
        (cons (f (car xs)) (map f (cdr xs))))))
;(define map (lambda (f xs)
;    (loop (res '() ys xs)
;        (cond
;            (nil? ys) '()
;            (recur (cons (f (car ys)) res) (cdr ys))))))

(defmacro swap! (x f) (list 'set! x (list f x)))

(defmacro defun (f args body)
    (list 'set! f
        (list 'lambda args body)))
(defmacro if (p x y)
    (list 'cond
        p x
        y))


; TODO: change to variadic func
(defmacro compose (f g) (list 'lambda '(x) (list f (list g 'x))))
(set! cadr (compose car cdr))
(set! cddr (compose cdr cdr))
(set! caddr (compose car cddr))
(set! cdddr (compose cdr cddr))
(defmacro letfun (exps body)
    (list 'let*
        ((defun f (expss)
            (if
                (nil? expss)
                ()
                (let*
                    (fun-name (car expss)
                    fun-args (cadr expss)
                    fun-body (caddr expss)
                    rest (cdddr expss))
                    (+
                        (list fun-name (list 'defun fun-name fun-args fun-body)))
                        (f rest)))) exps)
        body))

(defmacro defun-trace (f args body)
    (list 'defun f args
        (list 'let*
            (list 'res body)
            (list 'progn
                (list 'echo (name f) " " (cons 'list args) " " 'res)
                'res))))

; anaphoric lambda, argument binds to %
(defmacro # (& body) (list 'lambda '(%) body))

(defmacro doseq (seq-exprs body)
    ((defun doseq-helper (sxs body)
        (let*
            (var-name (car sxs)
            var-seq (cadr sxs)
            the-body (if
                (nil? (cddr sxs))
                body
                (doseq-helper (cddr sxs) body)))
            (list 'map
                (list 'lambda (list var-name) the-body)
                var-seq)))
    seq-exprs body))

(defun single? (x) (= (len x) 1))
(defmacro cons-if (p x y s) (list 'cons (list 'if p x y) s))

(defmacro -> (& x) ((defun ->-helper (y)
    (if
        (single? y)
        (car y)
        (let*
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (->-helper
                (cons-if
                    (atom? next-f)
                    (list next-f fst))
                    (cons (car next-f) fst (cdr next-f))
                    rest))))
    x))

(defmacro >-> (x) ((defun >->-helper (y)
    (if
        (single? y)
        (car y)
        (let*
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (>->-helper
                (cons-if
                    (atom? next-f)
                    (list next-f fst)
                    (list (list 'lambda '(%%) next-f) fst))
                    rest))))
    x))

(defmacro juxt (& fs)
    (list 'lambda '(x)
        (list 'map
            (list 'lambda '(f) '(f x))
            (cons 'list fs))))

; ============ FUNCTIONS SECTION ============

(defun not (x) (if x false true))

(defun dec (n) (- n 1))
(defun inc (n) (+ n 1))

(defun-trace fact-t (n)
    (if
        (= n 1) 1
        (* n (fact-t (dec n)))))

(defun-trace fib (n)
    (if
        (< n 2) n
        (+
            (fib (- n 1))
            (fib (- n 2)))))

(defun fact (n)
    (if
        (= n 1)
        1
        (*
            n
            (fact (dec n)))))


(defun range (n)
    (letfun
        (range-helper (k n)
            (if
                (= k n)
                '()
                (cons k (range-helper (inc k) n))))
        (range-helper 0 n)))


; (map* * '((1 2 3) (-1 0 1))
; (-1 0 3)
(defun map* (f xss)
    (if
        (apply or (map nil? xss)) '()
        (cons
            (apply f (map car xss))
            (map* f (map cdr xss)))))

; (*map (# (list % (inc %))) '(1 2 3))
; (1 2 2 3 3 4)
(defun *map (f xs)
    (if
        (nil? xs) '()
        (+
            (f (car xs))
            (*map f (cdr xs)))))

(defun take (n x)
    (if
        (or (nil? x) (= n 0))
        '()
        (cons (car x) (take (dec n) (cdr x)))))

(defun drop (n x)
    (if
        (or (nil? x) (= n 0))
        x
        (drop (dec n) (cdr x))))

(defun id (x) x)

; ============ PLAY ZONE ============








(echo "el0chka")
(doseq (x '(1 1 1) y '(1 3 5 7))
    (echo (* "*"y)))

(echo)
(echo "almaz")
(doseq (x '(1 3 5 7 5 3 1))
    (echo (* " " (- 7 x)) (* "*" (* x 2))))




(set! prompt
  (let* (cnt 0)
    (lambda () (progn
      (set! cnt (inc cnt))
      (+ "lis.py(" (str cnt) ")> ")))))



;(doseq (x '(-1 0 1)
;       y '(1 2 3))
;    (echo (* x y)))
