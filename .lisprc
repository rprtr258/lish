; ============ MACRO SECTION ============

(set! map (lambda (f xs)
    (cond
        (nil? xs) '()
        (cons (f (car xs)) (map f (cdr xs))))))

(defmacro swap! (x f) `(set! ~x (~f ~x)))

(defmacro defun (f args body)
    `(set! ~f
        (lambda ~args ~body)))

(defmacro if (p x y)
    `(cond ~p ~x ~y))


; TODO: change to variadic func
(defmacro compose (& fs)
  `(lambda (x) ~((defun compose-helper (fs)
    (if
      (nil? fs)
      'x
      (let*
        (cur-fun (car fs)
        rest-funs (cdr fs))
        `(~cur-fun ~(compose-helper rest-funs))))) fs)))
(set! cadr (compose car cdr))
(set! cddr (compose cdr cdr))
(set! caddr (compose car cdr cdr))
(set! cdddr (compose cdr cdc cdr))
(defmacro letfun (exps body)
  `(let*
    ~((defun f (expss)
      (if
        (nil? expss)
        ()
        (let*
          (fun-name (car expss)
          fun-args (cadr expss)
          fun-body (caddr expss)
          rest (cdddr expss))
          `(~fun-name (defun ~fun-name ~fun-args ~fun-body) ~@(f rest)))))
      exps)
    ~body))

(defmacro defun-trace (f args body)
    `(defun ~f ~args
        (let*
            (res ~body)
            (progn
                (echo ~(name f) " " (str ~@args) " = " 'res)
                res))))

; anaphoric lambda, argument binds to %
(defmacro # (body) `(lambda (%) ~body))

(defmacro doseq (seq-exprs body)
    ((defun doseq-helper (sxs body)
        (let*
            (var-name (car sxs)
            var-seq (cadr sxs)
            the-body (if
                (nil? (cddr sxs))
                body
                (doseq-helper (cddr sxs) body)))
            `(map
                (lambda (~var-name) ~the-body)
                ~var-seq)))
    seq-exprs body))

(defmacro cons-if (p x y s)
  `(cons (if ~p ~x ~y) s))

(defun single? (x) (= (len x) 1))
(defmacro -> (& x) ((defun ->-helper (y)
    (if
        (single? y)
        (car y)
        (let*
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (->-helper
                (cons-if
                    (atom? next-f)
                    (list next-f fst))
                    (cons (car next-f) fst (cdr next-f))
                    rest))))
    x))

(defmacro >-> (x) ((defun >->-helper (y)
    (if
        (single? y)
        (car y)
        (let*
            (fst (car y)
            next-f (cadr y)
            rest (cddr y))
            (>->-helper
                (cons-if
                    (atom? next-f)
                    `(~next-f ~fst)
                    `((lambda (%%) ~next-f) ~fst))
                    rest))))
    x))

(defmacro juxt (& fs)
    `(lambda (x)
        (map
            (lambda (f) (f x))
            ~fs)))

; ============ FUNCTIONS SECTION ============

(defun not (x) (if x false true))

(defun dec (n) (- n 1))
(defun inc (n) (+ n 1))

(defun-trace fact-t (n)
    (if
        (= n 1) 1
        (* n (fact-t (dec n)))))

(defun-trace fib (n)
    (if
        (< n 2) n
        (+
            (fib (- n 1))
            (fib (- n 2)))))

(defun fact (n)
    (if
        (= n 1)
        1
        (*
            n
            (fact (dec n)))))


(defun range (n)
    (letfun
        (range-helper (k n)
            (if
                (= k n)
                '()
                (cons k (range-helper (inc k) n))))
        (range-helper 0 n)))


; (map* * '((1 2 3) (-1 0 1))
; (-1 0 3)
(defun map* (f xss)
    (if
        (apply or (map nil? xss)) '()
        (cons
            (apply f (map car xss))
            (map* f (map cdr xss)))))

; (*map (# (list % (inc %))) '(1 2 3))
; (1 2 2 3 3 4)
(defun *map (f xs)
    (if
        (nil? xs) '()
        (+
            (f (car xs))
            (*map f (cdr xs)))))

(defun take (n x)
    (if
        (or (nil? x) (= n 0))
        '()
        (cons (car x) (take (dec n) (cdr x)))))

(defun drop (n x)
    (if
        (or (nil? x) (= n 0))
        x
        (drop (dec n) (cdr x))))

(defun id (x) x)

; ============ PLAY ZONE ============








(echo "el0chka")
(doseq (x '(1 1 1) y '(1 3 5 7))
    (echo (* "*" y)))

(echo)
(echo "almaz")
(doseq (x '(1 3 5 7 5 3 1))
    (echo (* " " (- 7 x)) (* "*" (* x 2))))

(echo (letfun (f (x) (+ 2 x) g (x) (* 3 x)) (f (g 4))))












(set! prompt
  (let* (cnt 0)
    (lambda () (progn
      (set! cnt (inc cnt))
      (+ "lis.py(" (str cnt) ")> ")))))



;(doseq (x '(-1 0 1)
;       y '(1 2 3))
;    (echo (* x y)))
