(define map (lambda (f xs)
    (cond
        (nil? xs) '()
        (cons (f (car xs)) (map f (cdr xs))))))

(define `` (lambda (f)
    (cond
        (atom? f) (list 'quote f)
        (= '~ (car f)) (car (cdr f))
        (cons
            'list
            (map `` f)))))
(defmacro ` (f) (`` f))

(defmacro defun (f args body) (` (define (~ f) (lambda (~ args) (~ body)))))
(defmacro if (p x y) (` (cond (~ p) (~ x) (~ y))))

(defun evens (x)
    (cond
        (nil? x) '()
        (cons
            (car x)
            (odds (cdr x)))))
(defun odds (x)
    (cond
        (nil? x) '()
        (evens (cdr x))))
(defmacro let (exps body)
    (cons (`
        (lambda
            (~ (evens exps))
            (~ body)))
        (odds exps)))

(defun cadr (x) (car (cdr x)))
(defun cddr (x) (cdr (cdr x)))
(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defmacro letfun (exps body)
    (let
        (f (defun f (expss)
            (cond
                (nil? expss) '()
                (let
                    (fun-name (car expss)
                    fun-args (cadr expss)
                    fun-body (caddr expss)
                    rest (cdddr expss))
                    (+
                        (` ((~ fun-name) (defun (~ fun-name) (~ fun-args) (~ fun-body))))
                        (f rest))))))
        (` (let
            (~ (f exps))
            (~ body)))))

(defmacro defun-trace (f args body)
    (` (define
        (~ f)
        (lambda
            (~ args)
            (let
                (res (~ body))
                (progn
                    (echo '(~ f) (~ (car args)) res)
                    res))))))

(defmacro # (body) (` (lambda (%) (~ body))))

(defun doseq-helper (sxs body)
    (let
        (var-name (car sxs)
        var-seq (car (cdr sxs))
        rest (cdr (cdr sxs)))
        (cond
            (nil? rest) (` (map
                (lambda ((~ var-name)) (~ body))
                (~ var-seq)))
            (` (map
                (lambda ((~ var-name)) (~ (doseq-helper rest body)))
                (~ var-seq))))))
(defmacro doseq (seq-exprs body) (doseq-helper seq-exprs body))













(defun dec (n) (- n 1))
(defun inc (n) (+ n 1))

(defun-trace fact (n)
    (cond
        (= n 1) 1
        (* n (fact (dec n)))))
(defun-trace fib (n)
    (cond
        (< n 2) n
        (+
            (fib (- n 1))
            (fib (- n 2)))))

(defun fact1 (n)
    (cond
        (= n 1) 1
        (*
            n
            (fact1 (dec n)))))

(defun range (n)
    ((defun range-helper (k n)
        (cond
            (= k n) '()
            (cons k (range-helper (inc k) n)))) 0 n))

(defun range2 (n)
    (let
        (range-helper (defun range-helper (k n)
            (cond
                (= k n) '()
                (cons k (range-helper (inc k) n)))))
        (range-helper 0 n)))

(defun range3 (n)
    (letfun
        (range-helper (k n) (cond
            (= k n) '()
            (cons k (range-helper (inc k) n))))
        (range-helper 0 n)))

(defun rainbow (s)
    (doseq
        (k (map (# (int (* (inc (cos (/ % 4))) (/ (len s) 2)))) (range 30)))
        (echo (* " " k) s)))















(rainbow (* "A" 10))

(doseq (x '(-1 0 1)
        y '(1 2 3))
  (echo (* x y)))
